---
title: "Optiver1"
author: "Group 1"
date: "2023-03-26"
output: html_document
---


#### Read in data

```{r}
DIRECTORYNAME <- "stocks"
stock.names <- list.files("stocks")
```

#### Divide each stock into buckets

```{r}
library(dplyr)
library(tidyr)
library(zoo)

stock.name <- "stock_0.csv"

stock.data <- read.csv(paste(DIRECTORYNAME, "/", stock.name, sep=''))

one.bucket <- stock.data[stock.data$time_id == 5, ]


complete_bucket <- function(bucket) {
  return (bucket %>%
    complete(seconds_in_bucket = seq(min(seconds_in_bucket), 599, 1)) %>%
    na.locf())
}

one.bucket <- complete_bucket(one.bucket)

```

```{r}
calculate_WAP_BidAsk <- function(bucket) {
  return(bucket %>% mutate(
    WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))
    %>% mutate(BidAskSpread = ask_price1 / bid_price1 - 1))
}
one.bucket <- calculate_WAP_BidAsk(one.bucket)
one.bucket
```

``` {r}
calculate_log_return <- function(bucket) {
  sec <- bucket %>% pull(seconds_in_bucket)
  price <- bucket %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  df <- data.frame("seconds_in_bucket" = sec[-1], "log_return" = log_r)
  return (df)
}
#Returns a dataframe with seconds in bucket and log_return.
```

```{r}
comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}
calculate_using_mean_time_bucket <- function(bucket, interval) {
  log_return_df <- calculate_log_return(bucket)
  bucket <- bucket %>% mutate(num_order = bid_size1 + ask_size1 + bid_size2 + ask_size2)
  bucket <- bucket %>% mutate(time_bucket = ceiling(seconds_in_bucket/interval))
  bucket <- bucket[-1,]
  
  WAP <- aggregate(WAP ~ time_bucket, data = bucket, FUN = mean)
  BAS <- aggregate(BidAskSpread ~ time_bucket, data = bucket, FUN = mean)
  num_order <- aggregate(num_order ~ time_bucket, data = bucket, FUN = mean)
  
  log_bucket <- log_return_df %>% mutate(time_bucket = ceiling(seconds_in_bucket/interval))
  vol <- aggregate(log_return ~ time_bucket, data = log_bucket, FUN = comp_vol)
  colnames(vol) <- c("time_bucket", "volatility")
  temp1 <- merge(WAP, BAS, by.x = "time_bucket")
  temp2 <- merge(temp1, num_order, by.x = "time_bucket")
  temp3 <- merge(temp2, vol, by.x = "time_bucket")
  return (temp3)
}
```

```{r}
regression_model <- function(meaned_df) {
  train.X <- meaned_df[1:16, ] %>% select(-c("volatility"))
  train.Y <- meaned_df[1:16, ] %>% select("volatility")
  test.X <- meaned_df[17:20, ] %>% select(-c("volatility"))
  test.Y <- meaned_df[17:20, ] %>% select("volatility")
  
}
```

```{r}
library(rugarch)
ARMA_GARCH_model <- function(bucket) {
  spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)), 
                   mean.model = list(armaOrder = c(1, 1)), 
                   distribution.model = "norm")
  log_return <- calculate_log_return(bucket)
  ARM <- ugarchfit(spec = spec, data = log_return %>% filter(seconds_in_bucket <= 480) %>% pull(log_return), solver = 'hybrid')
  setfixed(spec) <- as.list(coef(ARM))
  
  future.path <- fitted(ugarchpath(spec, n.sim = 30, m.sim = 1000))
  
  future.path[is.na(future.path)] <- 0
  
  return (mean(sqrt(colSums(future.path ^ 2))))
}

asdf <- ARMA_GARCH_model(one.bucket)
asdf


```






something about seconds being skipped and just interpolating it copy paste the first value from the missing seconds to the next

#### First analysis
```{R}
library(tseries)
library(ggplot2)
library(tidyverse)
library(tsfeatures)
library(devtools)
library(class)
#600 seconds so take 0~480
linear.regression <- function(bucket) {
  
  bucket <- bucket %>% mutate(time_bucket = ceiling((seconds_in_bucket + 1) / 30))
  
  bucket <- bucket %>% mutate(
    WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))
  bucket <- bucket %>% mutate(BidAskSpread = ask_price1 / bid_price1 - 1)

  
  
  training.X <- subset(bucket, seconds_in_bucket >= 0 & seconds_in_bucket <= 479)
  
  sec <- training.X %>% pull(seconds_in_bucket)
  price <- training.X %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1 <- data.frame(time = sec[-1], log_return = log_r)
  time.no.change <- (1:480)[!(1:480 %in% log_r1$time)]
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1 <- rbind(log_r1, new.df)
    log_r1 <- log_r1[order(log_r1$time), ]
  }
  
  training.Y <- list()
  comp_vol <- function(x) {
    return (sqrt(sum(x ^ 2)))
  }
  
  for (i in 1 : length(log_r1)) {
    log_r1 <- log_r1 %>% mutate(time_bucket = ceiling(time/ 30))
    training.Y <- aggregate(log_return ~ time_bucket, data = log_r1, FUN = comp_vol)
    colnames(training.Y) <- c('time_bucket', 'volatility')
  }

  testing.X <- subset(bucket, seconds_in_bucket >= 480)
  
  sec <- testing.X %>% pull(seconds_in_bucket)
  price <- testing.X %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1 <- data.frame(time = sec[-1], log_return = log_r)
  time.no.change <- (481:600)[!(480:600 %in% log_r1$time)]
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1 <- rbind(log_r1, new.df)
    log_r1 <- log_r1[order(log_r1$time), ]
  }
  
  testing.Y <- list()
  comp_vol <- function(x) {
    return (sqrt(sum(x ^ 2)))
  }
  
  for (i in 1 : length(log_r1)) {
    log_r1 <- log_r1 %>% mutate(time_bucket = ceiling(time / 30))
    testing.Y <- aggregate(log_return ~ time_bucket, data = log_r1, FUN = comp_vol)
    colnames(testing.Y) <- c('time_bucket', 'volatility')
  }


  training.X <- split(training.X, training.X$time_bucket)
  training.X.real <- c()
  
  testing.X <- split(testing.X, testing.X$time_bucket)
  testing.X.real <- c()
  
  for ( x in training.X) {
    x <- data.frame(x)
    training.X.real <- append(training.X.real, mean(x$WAP))
  }
  
  for ( x in testing.X) {
    x <- data.frame(x)
    testing.X.real <- append(testing.X.real, mean(x$WAP))
  }
  
  
}
linear.regression(one.bucket)



```



```{r}

library(xts)
library(quantmod)

# Download some sample intraday price data
getSymbols("AAPL", from = "2022-01-01", to = "2022-01-31", src = "yahoo")

# Calculate the log returns
log_returns <- diff(log(Cl(AAPL)))

# Resample the log returns to daily frequency
daily_log_returns <- to.daily(log_returns)

# Calculate the realized power
realized_power <- exp(2 * cumsum(daily_log_returns^2))



linear.regression <- function(bucket) {
  log_returns <- diff(log(Cl(bucket)))
}

linear.regression(one.bucket)

```




































```{r}
library(dplyr)
library(tidyr)
library(zoo)

for_each_bucket <- function(directory_name, stock_name, FUNC) {
  stock.data <- read.csv(paste(directory_name, "/", stock_name, sep=''))
  results <- c()
  group <- 
  for (bucket_id in bucket_ids) {
    bucket.data <- stock.data[stock.data$time_id == bucket_id, ]
    bucket.inter <- bucket.data %>% 
    complete(seconds_in_bucket = seq(min(seconds_in_bucket), max(seconds_in_bucket) , 1)) %>%
    na.locf()
    results <- append(results, FUNC(bucket.inter))
  }
  return(results)
}

mean_bid_price1 <- function(bucket.data) {
  return(mean(bucket.data$bid_price1))
}

mean_WAP <- function(bucket.data) {
  bucket.data <- bucket.data %>% mutate(
  WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))
  return(mean(bucket.data$WAP))
}

mean_volatility <- function(bucket.data) {
  
}

results <- for_each_bucket("stocks", stock.names[1], mean_WAP)
boxplot(results)
```

```{r}
Get_random_buckets <- function(directory, stock.names) {
  random.buckets <- data.frame()
  selected.time_id <- c()
  for (name in stock.names){
    stock.data <- read.csv(paste(directory, "/", name, sep=''))
    print(paste(directory, "/", name, sep=''))
    bucket <- c()
    
    random.time.id <- sample(stock.data$time_id, 1)
    while (random.time.id %in% selected.time_id) {
      random.time.id <- sample(stock.data$time_id, 1)
    }
    
    bucket.data <- stock.data[stock.data$time_id == random.time.id, ]
    bucket.inter <- bucket.data %>% 
    complete(seconds_in_bucket = seq(min(seconds_in_bucket), max(seconds_in_bucket) , 1)) %>%
    na.locf()
    random.buckets <- rbind(random.buckets, data.frame(bucket.inter))
  }
  return (random.buckets)
}

random.buckets <- Get_random_buckets("stocks", stock.names)
```

```{r}






















