---
title: "Optiver1"
author: "Group 1"
date: "2023-03-26"
output: html_document
---


#### Read in data
Make sure all the csv data is in a directory named 'stocks'
```{r, eval=FALSE}
DIRECTORYNAME <- "stocks"
stock.names <- list.files("stocks")
stock.data <- list()
for (i in 1:length(stock.names)) {
  path <- paste(DIRECTORYNAME, stock.names[i], sep='/')
  print(path)
  stock.data[[i]] <- read.csv(path)
}
```

```{r}
library(dplyr)
library(tidyr)
library(zoo)
library(e1071)
library(rugarch)
```


```{r}
maximum_bid_price <- c()
for (i in seq_along(stock.data)) {
  maximum_bid_price <- append(maximum_bid_price, max(stock.data[[i]]$bid_price1))
}

boxplot(maximum_bid_price, main = "Maximum bid_price1", ylab="dollars", xlab="All stocks")
```

```{r}
maximum_ask_price <- c()
for (i in seq_along(stock.data)) {
  maximum_ask_price <- append(maximum_ask_price, max(stock.data[[i]]$ask_price1))
}

boxplot(maximum_ask_price, main = "Maximum ask_price1", ylab="dollars", xlab="All stocks")
```
Apparently they all have 3830 buckets each
```{r}
number_of_buckets <- c()
for (i in seq_along(stock.data)) {
  number_of_buckets <- append(number_of_buckets, length(unique(stock.data[[i]]$time_id)))
}

boxplot(number_of_buckets, main = "Number of buckets in each stock", ylab="bucket count", xlab="All stocks")

```



###Test Bucket dont worry about this one, use complete_bucket function on every bucket
```{r}
test.bucket <- stock.data[[1]][stock.data[[1]]$time_id == 5, ]

complete_bucket <- function(bucket) {
  return (bucket %>%
    complete(seconds_in_bucket = seq(min(seconds_in_bucket), 599, 1)) %>%
    na.locf())
}
```

####Function:
Takes in a bucket and returns the same bucket but with two additional columns: WAP and BAS
```{r}
calculate_WAP_BidAsk <- function(bucket) {
  return(bucket %>% mutate(
    WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))
    %>% mutate(BidAskSpread = ask_price1 / bid_price1 - 1))
}
```

####Function:
Takes in a bucket and returns a list with two columns: seconds_in_bucket and the corresponding log_return for that time
``` {r}
calculate_log_return <- function(bucket) {
  sec <- bucket %>% pull(seconds_in_bucket)
  price <- bucket %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  df <- data.frame("seconds_in_bucket" = sec[-1], "log_return" = log_r)
  return (df)
}
#Returns a dataframe with seconds in bucket and log_return.
```

####Function:
Takes in a bucket and a time interval to divide the bucket into (default interval=30)
It will spit out a new dataframe with the following columns:
- time_bucket -> what interval (0~30 or 30~60 etc.)
- BAS -> the average BAS for that interval
- WAP -> the average WAP for that interval
- num_order -> the average num_order for that interval
- volatility -> the average volatility for that interval
```{r}
comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}
calculate_using_mean_time_bucket <- function(bucket, interval=30) {
  bucket <- calculate_WAP_BidAsk(bucket)
  log_return_df <- calculate_log_return(bucket)
  bucket <- bucket %>% mutate(num_order = bid_size1 + ask_size1 + bid_size2 + ask_size2)
  bucket <- bucket %>% mutate(time_bucket = ceiling(seconds_in_bucket/interval))
  bucket <- bucket[-1,]
  
  WAP <- aggregate(WAP ~ time_bucket, data = bucket, FUN = mean)
  BAS <- aggregate(BidAskSpread ~ time_bucket, data = bucket, FUN = mean)
  num_order <- aggregate(num_order ~ time_bucket, data = bucket, FUN = mean)
  
  log_bucket <- log_return_df %>% mutate(time_bucket = ceiling(seconds_in_bucket/interval))
  vol <- aggregate(log_return ~ time_bucket, data = log_bucket, FUN = comp_vol)
  colnames(vol) <- c("time_bucket", "volatility")
  temp1 <- merge(WAP, BAS, by.x = "time_bucket")
  temp2 <- merge(temp1, num_order, by.x = "time_bucket")
  temp3 <- merge(temp2, vol, by.x = "time_bucket")
  return (temp3)
}
```





####Given a dataframe with predicted column and actual column of volatilities, return the accuracy based on MSE
```{r}
MSE <- function(results) {
  predicted <- results$predicted
  actual <- results$actual
  return (mean((predicted - actual) ^ 2))
}
```

####Given a dataframe with predicted column and actual column of volatilities, return the accuracy based on QLIKE
```{r}
QLIKE <- function(results) {
  predicted <- results$predicted
  actual <- results$actual
  return (mean(2 * (actual * log(actual/predicted) - (actual - predicted))))
}
```

####Given a dataframe with predicted column and actual column of volatilities, return the accuracy based on MAE
```{r}
MAE <- function(results) {
  predicted <- results$predicted
  actual <- results$actual
  return (mae(predicted, actual))
}
```




#Given a bucket, as in the one with all the mean values, perform linear regression prediction.
```{r}
regression_model <- function(bucket) {
  bucket <- complete_bucket(bucket)
  meaned_df <- calculate_using_mean_time_bucket(bucket)
  predicted <- c()
  
  train <- meaned_df[1:16, ] %>% select(c("time_bucket"))
  test <- meaned_df[17, ]
  model <- lm(volatility ~ time_bucket, data = meaned_df)
  predicted_val <- predict(model, newdata = test)
  predicted <- append(predicted, predicted_val)
  
  train <- meaned_df[2:17, ] %>% select(c("time_bucket"))
  test <- meaned_df[17, ]
  model <- lm(volatility ~ time_bucket, data = meaned_df)
  predicted_val <- predict(model, newdata = test)
  predicted <- append(predicted, predicted_val)
  
  train <- meaned_df[3:18, ] %>% select(c("time_bucket"))
  test <- meaned_df[19, ]
  model <- lm(volatility ~ time_bucket, data = meaned_df)
  predicted_val <- predict(model, newdata = test)
  predicted <- append(predicted, predicted_val)
  
  train <- meaned_df[4:19, ] %>% select(c("time_bucket"))
  test <- meaned_df[20, ]
  model <- lm(volatility ~ time_bucket, data = meaned_df)
  predicted_val <- predict(model, newdata = test)
  predicted <- append(predicted, predicted_val)

  result <- data.frame(x = predicted, y = meaned_df[17:20, ] %>% select("volatility"))
  colnames(result) <- c('predicted', 'actual')
  return (result)
}
```

####Given a time series bucket, perform ARMA_GARCH prediction.
```{r}
ARMA_GARCH_model <- function(bucket) {
  bucket <- complete_bucket(bucket)
  bucket <- calculate_WAP_BidAsk(bucket)
  spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)), 
                   mean.model = list(armaOrder = c(1, 1)), 
                   distribution.model = "norm")
  log_return <- calculate_log_return(bucket)
  
  predicted <- c()
  
  
  ARM <- ugarchfit(spec = spec, data = log_return %>% filter(seconds_in_bucket <= 480) %>% pull(log_return), solver = 'hybrid')
  setfixed(spec) <- as.list(coef(ARM))
  future.path <- fitted(ugarchpath(spec, n.sim = 30, m.sim = 1000))
  future.path[is.na(future.path)] <- 0
  predicted <- append(predicted, mean(sqrt(colSums(future.path ^ 2))))

  ARM <- ugarchfit(spec = spec, data = log_return %>% filter((seconds_in_bucket > 30) & (seconds_in_bucket <= 510)) %>% pull(log_return), solver = 'hybrid')
  setfixed(spec) <- as.list(coef(ARM))
  future.path <- fitted(ugarchpath(spec, n.sim = 30, m.sim = 1000))
  future.path[is.na(future.path)] <- 0
  predicted <- append(predicted, mean(sqrt(colSums(future.path ^ 2))))
  
  ARM <- ugarchfit(spec = spec, data = log_return %>% filter((seconds_in_bucket > 60) & (seconds_in_bucket <= 540)) %>% pull(log_return), solver = 'hybrid')
  setfixed(spec) <- as.list(coef(ARM))
  future.path <- fitted(ugarchpath(spec, n.sim = 30, m.sim = 1000))
  future.path[is.na(future.path)] <- 0
  predicted <- append(predicted, mean(sqrt(colSums(future.path ^ 2))))
  
  ARM <- ugarchfit(spec = spec, data = log_return %>% filter((seconds_in_bucket > 90) & (seconds_in_bucket <= 570)) %>% pull(log_return), solver = 'hybrid')
  setfixed(spec) <- as.list(coef(ARM))
  future.path <- fitted(ugarchpath(spec, n.sim = 30, m.sim = 1000))
  future.path[is.na(future.path)] <- 0
  predicted <- append(predicted, mean(sqrt(colSums(future.path ^ 2))))
  
  df <- data.frame("predicted" = predicted, "actual" = calculate_using_mean_time_bucket(bucket, 30)[17:20, "volatility"])
  colnames(df) <- c("predicted", "actual")
  return(df)
}
```


```{r}
calculate_mean_volatility <- function(bucket) {
  return(mean(calculate_using_mean_time_bucket(complete(bucket))$volatility * 100))
}
```


```{r}
time_ids <- sample(unique(stock.data[[1]]$time_id), 1)

time_ids
```

```{r}
sampled.buckets <- c()
j <- 1
for (i in seq_along(stock.data)) {
  stock <- stock.data[[i]]
  
  for (id in time_ids) {
    bucket <- stock[stock$time_id == id, ]
    sampled.buckets[[j]] <- bucket
    j <- j + 1
  }
}
```


```{r, warning=FALSE}
y <- lapply(sampled.buckets, FUN=regression_model)
y.regression.acc <- lapply(y, FUN=MSE)

x <- lapply(sampled.buckets, FUN=calculate_mean_volatility)

y <- lapply(sampled.buckets, FUN=ARMA_GARCH_model)
y.arm.acc <- lapply(y, FUN=MSE)
```

```{r}
dev.new(width = 700, height = 330, unit = "px")
plot(x = x, y = y.regression.acc, col="red", ylim=c(0, 0.000002), xlab="Volatility", ylab="Accuracy in MSE (Lower is better)", main="Regression vs ARMA_GARCH", las=1, cex.lab=1, mgp=c(3,1,0))

abline(lm(unlist(y.regression.acc) ~ unlist(x)), col="red")

points(x = x, y = y.arm.acc, col="blue")
abline(lm(unlist(y.arm.acc) ~ unlist(x)), col="blue")

legend("topright", legend=c("Regression", "ARMA_GARCH"),
       col=c("red", "blue"), lty=1:2, cex=0.8)
```




```{r}

sampled.buckets[[1]]
```



















































####Not decided yet
```{r}
svm_model <- function(meaned_df) {
  
  predicted <- c()
  
  train.X <- meaned_df[1:16, ] %>% select(c("time_bucket"))
  train.Y <- meaned_df[1:16, ] %>% select("volatility")
  test.X <- meaned_df[17, ] %>% select(c("time_bucket"))
  test.Y <- meaned_df[17, ] %>% select("volatility")
  svm_res <- e1071::svm(x = train.X, y = train.Y)
  fit <- predict(svm_res, test.X)
  predicted <- append(predicted, fit)
  
  train.X <- meaned_df[2:17, ] %>% select(c("time_bucket"))
  train.Y <- meaned_df[2:17, ] %>% select("volatility")
  test.X <- meaned_df[18, ] %>% select(c("time_bucket"))
  test.Y <- meaned_df[18, ] %>% select("volatility")
  svm_res <- e1071::svm(x = train.X, y = train.Y)
  fit <- predict(svm_res, test.X)
  test.Y <- as.list(test.Y)
  predicted <- append(predicted, fit)
  
  train.X <- meaned_df[3:18, ] %>% select(c("time_bucket"))
  train.Y <- meaned_df[3:18, ] %>% select("volatility")
  test.X <- meaned_df[19, ] %>% select(c("time_bucket"))
  test.Y <- meaned_df[19, ] %>% select("volatility")
  svm_res <- e1071::svm(x = train.X, y = train.Y)
  fit <- predict(svm_res, test.X)
  predicted <- append(predicted, fit)
  
  train.X <- meaned_df[4:19, ] %>% select(c("time_bucket"))
  train.Y <- meaned_df[4:19, ] %>% select("volatility")
  test.X <- meaned_df[20, ] %>% select(c("time_bucket"))
  test.Y <- meaned_df[20, ] %>% select("volatility")
  svm_res <- e1071::svm(x = train.X, y = train.Y)
  fit <- predict(svm_res, test.X)
  predicted <- append(predicted, fit)
  
  result <- data.frame(x = predicted, y = meaned_df[17:20, ] %>% select("volatility"))
  colnames(result) <- c('predicted_volatility', 'actual_volatility')
  return (result)
}
result <- svm_model(one.bucket)
MSE(result)
QLIKE(result)
#mae(result$actual_volatility, result$predicted_volatility)
```


